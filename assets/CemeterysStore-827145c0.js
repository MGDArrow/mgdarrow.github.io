import{Q as l,M as o,s}from"./index-384c84b3.js";const C=l("CemeterysStore",{state(){return{cemeterys:[]}},actions:{async getCemeterys(){let e=a("CemeterysPostArray"),t=a("CemeterysDeleteArray");if(o().status)e&&await s.from("CEMETERY").insert(e).then(()=>{window.localStorage.removeItem("CemeterysPostArray"),this.getCemeterys()}),t&&await s.from("CEMETERY").delete().in("name",t).then(()=>{window.localStorage.removeItem("CemeterysDeleteArray"),this.getCemeterys()}),await s.from("CEMETERY").select("*").order("id",{ascending:!0}).then(r=>{this.cemeterys=r.data,m("CemeterysBigData",r.data)});else{let r=a("CemeterysBigData");e&&e.forEach(i=>{r.push(i)}),t&&t.forEach(i=>{let y=r.findIndex(n=>n.name===i.name);y!==-1&&r.splice(y,1)}),this.cemeterys=r}},async postCemeterys(e){if(o().status)await s.from("CEMETERY").insert(e);else if(window.localStorage.getItem("CemeterysPostArray")){let t=a("CemeterysPostArray");t.push(e),m("CemeterysPostArray",t)}else m("CemeterysPostArray",[e]);this.getCemeterys()},async putCemeterys(e,t){await s.from("CEMETERY").update(e).eq("id",t),this.getCemeterys()},async deleteCemeterys(e){if(o().status)await s.from("CEMETERY").delete().eq("id",e.id);else if(window.localStorage.getItem("CemeterysDeleteArray")){let t=a("CemeterysDeleteArray");t.push(e.name),m("CemeterysDeleteArray",t)}else m("CemeterysDeleteArray",[e.name]);this.getCemeterys()}}});function a(e){return JSON.parse(window.localStorage.getItem(e))}function m(e,t){window.localStorage.setItem(e,JSON.stringify(t))}export{C as u};
